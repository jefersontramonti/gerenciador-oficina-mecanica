name: Deploy PitStop

on:
  push:
    branches: [main]
  workflow_dispatch:  # Permite deploy manual

env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}/backend
          tags: |
            type=sha,prefix=
            type=raw,value=latest

      - name: Build and push Backend
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Extract metadata for Frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}/frontend
          tags: |
            type=sha,prefix=
            type=raw,value=latest

      - name: Build and push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          build-args: |
            VITE_API_URL=${{ secrets.VITE_API_URL }}
            VITE_WS_URL=${{ secrets.VITE_WS_URL }}
            VITE_API_BASE_URL=${{ secrets.VITE_API_BASE_URL }}
          no-cache: true

  deploy:
    name: Deploy to VPS
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Create directory structure
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            mkdir -p /opt/pitstop/backups
            mkdir -p /opt/pitstop/logs
          ENDSSH

      - name: Backup database and uploads before deploy
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            cd /opt/pitstop
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)

            # Verifica se o container postgres está rodando
            if docker ps --format '{{.Names}}' | grep -q pitstop-postgres; then
              echo "=== Criando backup do banco de dados ==="
              BACKUP_FILE="/opt/pitstop/backups/pitstop_db_${TIMESTAMP}.sql.gz"
              docker exec pitstop-postgres pg_dump -U pitstop pitstop_db 2>/dev/null | gzip > "$BACKUP_FILE"

              if [ -s "$BACKUP_FILE" ]; then
                echo "Backup DB criado: $BACKUP_FILE"
                ls -lh "$BACKUP_FILE"
              else
                echo "AVISO: Backup DB vazio ou falhou (primeira instalacao?)"
                rm -f "$BACKUP_FILE"
              fi

              # Mantém apenas os últimos 10 backups de DB
              ls -t /opt/pitstop/backups/pitstop_db_*.sql.gz 2>/dev/null | tail -n +11 | xargs -r rm -f
            else
              echo "Container postgres nao encontrado - primeira instalacao"
            fi

            # Backup dos uploads (arquivos de anexos)
            if [ -d "/var/pitstop/uploads" ] && [ "$(ls -A /var/pitstop/uploads 2>/dev/null)" ]; then
              echo "=== Criando backup dos uploads ==="
              UPLOADS_BACKUP="/opt/pitstop/backups/pitstop_uploads_${TIMESTAMP}.tar.gz"
              tar -czf "$UPLOADS_BACKUP" -C /var/pitstop uploads
              echo "Backup uploads criado: $UPLOADS_BACKUP"
              ls -lh "$UPLOADS_BACKUP"

              # Mantém apenas os últimos 5 backups de uploads
              ls -t /opt/pitstop/backups/pitstop_uploads_*.tar.gz 2>/dev/null | tail -n +6 | xargs -r rm -f
            else
              echo "Diretorio de uploads vazio - nada a fazer backup"
            fi
          ENDSSH

      - name: Save current image tags for rollback
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            cd /opt/pitstop

            # Salva as imagens atuais para possível rollback
            if docker ps --format '{{.Names}}' | grep -q pitstop-backend; then
              docker inspect pitstop-backend --format='{{.Config.Image}}' > /opt/pitstop/.last_backend_image 2>/dev/null || true
            fi
            if docker ps --format '{{.Names}}' | grep -q pitstop-frontend; then
              docker inspect pitstop-frontend --format='{{.Config.Image}}' > /opt/pitstop/.last_frontend_image 2>/dev/null || true
            fi
          ENDSSH

      - name: Copy docker-compose file
        run: |
          scp docker-compose.prod.yml ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:/opt/pitstop/docker-compose.prod.yml

      - name: Create uploads directory
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            echo "=== Criando diretório de uploads ==="
            mkdir -p /var/pitstop/uploads
            # UID 1001 é o usuário 'pitstop' dentro do container (ver Dockerfile)
            chown -R 1001:1001 /var/pitstop/uploads
            chmod -R 755 /var/pitstop/uploads
            echo "Diretório de uploads configurado:"
            ls -la /var/pitstop/
          ENDSSH

      - name: Create/Update .env file
        run: |
          # Criar arquivo .env localmente
          cat > /tmp/pitstop.env << 'ENVFILE'
          POSTGRES_PITSTOP_DB=${{ secrets.POSTGRES_PITSTOP_DB }}
          POSTGRES_PITSTOP_USER=${{ secrets.POSTGRES_PITSTOP_USER }}
          POSTGRES_PITSTOP_PASSWORD=${{ secrets.POSTGRES_PITSTOP_PASSWORD }}
          REDIS_HOST=pitstop-redis
          REDIS_PORT=6379
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          DATABASE_USERNAME=${{ secrets.DATABASE_USERNAME }}
          DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          APP_FRONTEND_URL=${{ secrets.APP_FRONTEND_URL }}
          APP_BASE_URL=${{ secrets.APP_BASE_URL }}
          CORS_ALLOWED_ORIGINS=${{ secrets.CORS_ALLOWED_ORIGINS }}
          SPRING_PROFILES_ACTIVE=prod
          APP_COOKIE_DOMAIN=
          APP_STORAGE_BASE_PATH=/var/pitstop/uploads
          DOMAIN_API=app.pitstopai.com.br
          EVOLUTION_API_URL=${{ secrets.EVOLUTION_API_URL }}
          EVOLUTION_API_KEY=${{ secrets.EVOLUTION_API_KEY }}
          MAIL_HOST=${{ secrets.MAIL_HOST }}
          MAIL_PORT=${{ secrets.MAIL_PORT }}
          MAIL_USERNAME=${{ secrets.MAIL_USERNAME }}
          MAIL_PASSWORD=${{ secrets.MAIL_PASSWORD }}
          MAIL_FROM_NAME=${{ secrets.MAIL_FROM_NAME }}
          MAIL_SMTP_AUTH=${{ secrets.MAIL_SMTP_AUTH }}
          MAIL_SMTP_SSL_ENABLE=${{ secrets.MAIL_SMTP_SSL_ENABLE }}
          MAIL_SMTP_STARTTLS_ENABLE=${{ secrets.MAIL_SMTP_STARTTLS_ENABLE }}
          ENVFILE

          # Remover indentação do arquivo
          sed -i 's/^          //' /tmp/pitstop.env

          # Backup do .env existente no servidor
          ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} \
            "if [ -f /opt/pitstop/.env ]; then cp /opt/pitstop/.env /opt/pitstop/.env.backup; fi"

          # Copiar arquivo para o servidor
          scp /tmp/pitstop.env ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:/opt/pitstop/.env

          # Limpar arquivo temporário
          rm /tmp/pitstop.env

      - name: Create external volumes if not exist
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            echo "=== Verificando volumes externos ==="

            # Cria volume do postgres se não existir
            if ! docker volume ls --format '{{.Name}}' | grep -q '^pitstop_postgres_data$'; then
              echo "Criando volume pitstop_postgres_data..."
              docker volume create pitstop_postgres_data
            else
              echo "Volume pitstop_postgres_data já existe"
            fi

            # Cria volume do redis se não existir
            if ! docker volume ls --format '{{.Name}}' | grep -q '^pitstop_redis_data$'; then
              echo "Criando volume pitstop_redis_data..."
              docker volume create pitstop_redis_data
            else
              echo "Volume pitstop_redis_data já existe"
            fi

            echo "Volumes existentes:"
            docker volume ls | grep pitstop
          ENDSSH

      - name: Deploy to VPS
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            cd /opt/pitstop

            echo "=== Login no GitHub Container Registry ==="
            echo "${{ secrets.GH_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            echo "=== Parando containers para atualização ==="
            docker compose -f docker-compose.prod.yml stop pitstop-backend pitstop-frontend || true
            docker compose -f docker-compose.prod.yml rm -f pitstop-backend pitstop-frontend || true

            echo "=== Removendo imagens antigas do frontend e backend ==="
            docker rmi ghcr.io/jefersontramonti/gerenciador-oficina-mecanica/frontend:latest || true
            docker rmi ghcr.io/jefersontramonti/gerenciador-oficina-mecanica/backend:latest || true

            echo "=== Pull das novas imagens (forçando download) ==="
            docker pull ghcr.io/jefersontramonti/gerenciador-oficina-mecanica/frontend:latest
            docker pull ghcr.io/jefersontramonti/gerenciador-oficina-mecanica/backend:latest

            echo "=== Tagueando imagens para uso no docker-compose ==="
            docker tag ghcr.io/jefersontramonti/gerenciador-oficina-mecanica/backend:latest pitstop-backend:latest
            docker tag ghcr.io/jefersontramonti/gerenciador-oficina-mecanica/frontend:latest pitstop-frontend:latest

            echo "=== Atualizando containers (forçando recreate) ==="
            docker compose -f docker-compose.prod.yml up -d --force-recreate --remove-orphans

            echo "=== Limpando imagens antigas ==="
            docker image prune -af

            echo "=== Status dos containers ==="
            docker compose -f docker-compose.prod.yml ps
          ENDSSH

      - name: Wait for application startup
        run: |
          echo "Aguardando aplicacao iniciar (90s)..."
          sleep 90

      - name: Health Check
        id: health_check
        run: |
          echo "=== Verificando saúde da aplicação ==="

          # Verifica backend health via SSH (interno)
          BACKEND_HEALTH=$(ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} \
            "curl -s -o /dev/null -w '%{http_code}' http://127.0.0.1:8080/actuator/health" || echo "000")

          echo "Backend health status: $BACKEND_HEALTH"

          if [ "$BACKEND_HEALTH" != "200" ]; then
            echo "health_failed=true" >> $GITHUB_OUTPUT
            echo "ERRO: Backend não está saudável!"
          else
            echo "health_failed=false" >> $GITHUB_OUTPUT
            echo "Backend está saudável!"
          fi

          # Verifica frontend
          FRONTEND_HEALTH=$(ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} \
            "curl -s -o /dev/null -w '%{http_code}' http://127.0.0.1:3000/" || echo "000")

          echo "Frontend health status: $FRONTEND_HEALTH"

          if [ "$FRONTEND_HEALTH" != "200" ]; then
            echo "AVISO: Frontend retornou $FRONTEND_HEALTH"
          else
            echo "Frontend está saudável!"
          fi

      - name: Rollback on failure
        if: steps.health_check.outputs.health_failed == 'true'
        run: |
          echo "=== INICIANDO ROLLBACK ==="
          ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            cd /opt/pitstop

            # Verifica se existem imagens anteriores para rollback
            if [ -f .last_backend_image ] && [ -f .last_frontend_image ]; then
              LAST_BACKEND=$(cat .last_backend_image)
              LAST_FRONTEND=$(cat .last_frontend_image)

              echo "Revertendo para:"
              echo "  Backend: $LAST_BACKEND"
              echo "  Frontend: $LAST_FRONTEND"

              # Para os containers
              docker compose -f docker-compose.prod.yml stop pitstop-backend pitstop-frontend

              # Remove os containers
              docker rm pitstop-backend pitstop-frontend 2>/dev/null || true

              # Inicia com as imagens anteriores
              docker run -d --name pitstop-backend \
                --network pitstop-internal-network \
                --env-file .env \
                -p 127.0.0.1:8080:8080 \
                --restart unless-stopped \
                $LAST_BACKEND

              docker run -d --name pitstop-frontend \
                --network pitstop-internal-network \
                -p 127.0.0.1:3000:80 \
                --restart unless-stopped \
                $LAST_FRONTEND

              echo "Rollback concluído!"
            else
              echo "Nenhuma imagem anterior encontrada para rollback"
              echo "Verificando logs do backend:"
              docker logs pitstop-backend --tail 50
            fi
          ENDSSH

      - name: Show deployment logs on failure
        if: failure()
        run: |
          echo "=== Logs do Backend ==="
          ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} \
            "docker logs pitstop-backend --tail 100" || true

          echo ""
          echo "=== Logs do Frontend ==="
          ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} \
            "docker logs pitstop-frontend --tail 50" || true

      - name: Deployment Summary
        if: always()
        run: |
          echo "=========================================="
          echo "         RESUMO DO DEPLOY"
          echo "=========================================="
          ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            echo "Containers:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep pitstop || echo "Nenhum container pitstop encontrado"

            echo ""
            echo "Volumes:"
            docker volume ls | grep pitstop || echo "Nenhum volume pitstop encontrado"

            echo ""
            echo "Backups disponíveis:"
            ls -lh /opt/pitstop/backups/*.sql.gz 2>/dev/null | tail -5 || echo "Nenhum backup encontrado"
          ENDSSH
